# T2.1.2 - Auto-Identifier Inertia: Technical Specification

**Component:** InertiaEstimator (Online System Identification)  
**Status:** ğŸ”¨ IN DEVELOPMENT  
**Priority:** HIGH (Critical for Phase 2 feedforward control)  
**Effort:** 35h (4 weeks)  
**Start Date:** February 18, 2026

---

## 1. EXECUTIVE SUMMARY

### Purpose
Implement an **online inertia identification algorithm** that estimates the total moment of inertia `J_total(R)` and friction coefficients in real-time during normal winding operation, without requiring dedicated test procedures.

### Why This Matters
- **Feedforward control accuracy** depends critically on knowing `J_total` (varies 1:100 from empty to full bobbin)
- **Current limitation:** Manual calibration required for each material change
- **Solution:** Auto-identify during startup â†’ Adaptive control throughout operation

### Key Innovation
**Physics-based estimation** combining:
1. Analytical model: `J_total = J_motor + J_roller + J_web(R)`
2. Step-response identification: Measure acceleration response to torque
3. Online refinement: Recursive least-squares updating

---

## 2. TECHNICAL REQUIREMENTS

### 2.1 Functional Requirements

| ID | Requirement | Description |
|----|-------------|-------------|
| **F1** | Online identification | Estimate J during normal operation (no dedicated test mode) |
| **F2** | Multi-parameter estimation | Identify: J_total, f_coulomb, f_viscous |
| **F3** | Adaptive refinement | Update estimates when material/radius changes |
| **F4** | Uncertainty quantification | Provide confidence intervals (Â±%) |
| **F5** | State management | States: IDLE â†’ IDENTIFYING â†’ CONFIRMED â†’ TRACKING |

### 2.2 Performance Requirements

| ID | Requirement | Target | Rationale |
|----|-------------|--------|-----------|
| **P1** | Precision | Â±5% error | Feedforward requires <10% J accuracy |
| **P2** | Convergence time | <10 seconds | Acceptable startup delay |
| **P3** | Latency | <200 ms | Real-time control loop compatible |
| **P4** | Update rate | 1 Hz | Balance responsiveness vs stability |

### 2.3 Robustness Requirements

| ID | Requirement | Condition | Expected Behavior |
|----|-------------|-----------|-------------------|
| **R1** | Noise rejection | Â±2% encoder noise | Identification accuracy degrades <10% |
| **R2** | Low-velocity handling | v < 1 m/min | Defer identification until v > 5 m/min |
| **R3** | Parameter drift detection | Î”J > 20% | Trigger re-identification |
| **R4** | Failure detection | Convergence timeout | Revert to nominal model |

---

## 3. MATHEMATICAL FOUNDATION

### 3.1 System Model

**Dynamics:**
```
Ï„_motor = J_total Â· Î± + f_friction + T_web Â· R

where:
  Ï„_motor: Motor torque command (NÂ·m)
  J_total: Total moment of inertia (kgÂ·mÂ²)
  Î± = dÏ‰/dt: Angular acceleration (rad/sÂ²)
  f_friction: Friction torque (NÂ·m)
  T_web: Web tension (N)
  R: Winding radius (m)
```

**Inertia Decomposition:**
```
J_total(R) = J_motor + J_roller + J_web(R)

J_web(R) = (ÏÂ·Ï€Â·L/2) Â· (Râ´ - R_coreâ´)

Parameters:
  Ï: Material density (kg/mÂ²) - TO IDENTIFY
  L: Roller width (m) - KNOWN
  R_core: Mandrel radius (m) - KNOWN
```

**Friction Model (Stribeck):**
```
f_friction = f_coulombÂ·sign(Ï‰) + f_viscousÂ·Ï‰

Parameters to identify:
  f_coulomb: Static/Coulomb friction (NÂ·m)
  f_viscous: Viscous friction coefficient (NÂ·mÂ·s/rad)
```

### 3.2 Identification Approach: Step Response Method

**Test Protocol:**
```
1. Apply torque step: Ï„ = Ï„_nominal â†’ Ï„_nominal + Î”Ï„
2. Measure acceleration response: Î±(t)
3. Calculate nominal torque components:
   - T_webÂ·R (from tension sensor or model)
   - f_friction (from prior estimate)
4. Solve for J:
   J = (Î”Ï„ - Î”T_webÂ·R) / Î”Î±
```

**Least-Squares Formulation:**
```
Model: Ï„_motor[k] = JÂ·Î±[k] + f_cÂ·sign(Ï‰[k]) + f_vÂ·Ï‰[k] + TÂ·R

Arrange as linear regression:
  [Ï„_motor - TÂ·R] = [Î±  sign(Ï‰)  Ï‰] Â· [J  f_c  f_v]áµ€

Solve via normal equations:
  Î¸Ì‚ = (Xáµ€X)â»Â¹Â·Xáµ€Â·y
  
  where Î¸Ì‚ = [J  f_c  f_v]áµ€
```

**Recursive Update (Online Refinement):**
```
RLS (Recursive Least-Squares):

Î¸Ì‚[k] = Î¸Ì‚[k-1] + K[k]Â·(y[k] - Ï†[k]Â·Î¸Ì‚[k-1])

K[k] = P[k-1]Â·Ï†[k] / (Î» + Ï†[k]áµ€Â·P[k-1]Â·Ï†[k])

P[k] = (1/Î»)Â·(P[k-1] - K[k]Â·Ï†[k]áµ€Â·P[k-1])

Parameters:
  Î»: Forgetting factor (0.98-0.995)
  P: Covariance matrix (uncertainty)
  Ï†[k]: Regressor vector [Î±[k], sign(Ï‰[k]), Ï‰[k]]
```

---

## 4. ALGORITHM DESIGN

### 4.1 State Machine

```
â”Œâ”€â”€â”€â”€â”€â”€â”  Initialize  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  Collect data  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ IDLE â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ IDENTIFYING  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ CONFIRMEDâ”‚
â””â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  (>100 samples)â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚                               â”‚
                            â”‚ Timeout (>30s)                â”‚ Track 
                            â†“                               â†“
                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                       â”‚ FAILURE â”‚                     â”‚ TRACKING â”‚
                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                            â”‚
                                                            â”‚Î”J>20%
                                                            â†“
                                                       Re-identify
```

### 4.2 Core Methods

#### `identify_batch(tau_data, omega_data, alpha_data, T_web, R)`
**Purpose:** Initial batch identification from collected data

**Inputs:**
- `tau_data`: Motor torque commands (NÂ·m) [array, length N]
- `omega_data`: Angular velocities (rad/s) [array, length N]
- `alpha_data`: Angular accelerations (rad/sÂ²) [array, length N]
- `T_web`: Web tension (N) [scalar or array]
- `R`: Winding radius (m) [scalar or array]

**Outputs:**
- `J_estimated`: Total inertia (kgÂ·mÂ²)
- `f_coulomb`: Coulomb friction (NÂ·m)
- `f_viscous`: Viscous friction (NÂ·mÂ·s/rad)
- `uncertainty`: Estimate uncertainty (%)

**Algorithm:**
```python
1. Construct regressor matrix X:
   X[i] = [alpha_data[i], sign(omega_data[i]), omega_data[i]]

2. Construct target vector y:
   y[i] = tau_data[i] - T_web[i] * R[i]

3. Solve least-squares:
   theta = (X.T @ X)^-1 @ X.T @ y
   [J, f_c, f_v] = theta

4. Calculate residuals:
   residuals = y - X @ theta
   uncertainty = std(residuals) / mean(|y|) * 100

5. Return estimates + uncertainty
```

#### `update_online(tau, omega, alpha, T_web, R)`
**Purpose:** Online recursive update (RLS)

**Inputs:** Current measurement (single timestep)

**Outputs:** Updated estimate + covariance

**Algorithm:**
```python
1. Form regressor: phi = [alpha, sign(omega), omega]
2. Prediction error: e = (tau - T_web*R) - phi @ theta_prev
3. Calculate gain: K = P @ phi / (lambda + phi.T @ P @ phi)
4. Update estimate: theta = theta_prev + K * e
5. Update covariance: P = (P - K @ phi.T @ P) / lambda
6. Return theta, P
```

#### `calculate_inertia_model(R, rho_estimated)`
**Purpose:** Analytical calculation from identified density

**Algorithm:**
```python
J_motor = KNOWN_CONSTANT  # From motor datasheet
J_roller = KNOWN_CONSTANT  # From mechanical design
J_web = (rho * pi * L / 2) * (R**4 - R_core**4)
J_total = J_motor + J_roller + J_web
return J_total
```

---

## 5. IMPLEMENTATION STRUCTURE

### 5.1 Class Design

```python
@dataclass
class InertiaEstimate:
    """Output structure for inertia estimation"""
    J_total: float              # Total inertia (kgÂ·mÂ²)
    J_web: float                # Web contribution (kgÂ·mÂ²)
    f_coulomb: float            # Coulomb friction (NÂ·m)
    f_viscous: float            # Viscous friction (NÂ·mÂ·s/rad)
    rho_estimated: float        # Material density (kg/mÂ²)
    uncertainty: float          # Estimate uncertainty (%)
    confidence: float           # Confidence score (0-1)
    state: str                  # State machine state
    timestamp: float            # Measurement time (s)

class InertiaEstimator:
    """Auto-identification of total inertia and friction"""
    
    def __init__(self, J_motor, J_roller, R_core, L, dt=0.01):
        # System parameters (known)
        self.J_motor = J_motor
        self.J_roller = J_roller
        self.R_core = R_core
        self.L = L
        self.dt = dt
        
        # Identification state
        self.state = "IDLE"
        self.theta = np.array([0.1, 1.0, 0.01])  # [J, f_c, f_v]
        self.P = np.eye(3) * 10  # Covariance matrix
        self.lambda_rls = 0.995  # Forgetting factor
        
        # Data buffer
        self.data_buffer = []
        self.min_samples = 100
        
    def update(self, tau_motor, omega, alpha, T_web, R) -> InertiaEstimate:
        """Main update method called at control rate"""
        
    def identify_batch(self, tau_data, omega_data, alpha_data, T_web, R):
        """Batch identification from collected data"""
        
    def update_online_rls(self, tau, omega, alpha, T_web, R):
        """Recursive least-squares update"""
        
    def calculate_analytical_J(self, R, rho):
        """Calculate J_total from physics model"""
        
    def check_convergence(self) -> bool:
        """Check if identification has converged"""
        
    def get_uncertainty(self) -> float:
        """Calculate current estimate uncertainty"""
```

### 5.2 File Structure

```
src/prowinder/control/
â”œâ”€â”€ inertia_estimator.py          (NEW - 450 lines)
â”‚   â”œâ”€â”€ InertiaEstimate (dataclass)
â”‚   â”œâ”€â”€ InertiaEstimator (main class)
â”‚   â””â”€â”€ Helper functions

tests/
â”œâ”€â”€ test_inertia_estimator.py     (NEW - 300 lines)
â”‚   â”œâ”€â”€ TestInertiaEstimatorAccuracy (6 tests)
â”‚   â”œâ”€â”€ TestInertiaEstimatorConvergence (4 tests)
â”‚   â”œâ”€â”€ TestInertiaEstimatorRobustness (5 tests)
â”‚   â””â”€â”€ Fixtures & test data

scripts/validation/
â”œâ”€â”€ validate_T2.1.2.py             (NEW - 150 lines)
â”‚   â””â”€â”€ Roadmap compliance tests

docs/algorithms/
â”œâ”€â”€ InertiaEstimator.md            (NEW - 400 lines)
â”‚   â””â”€â”€ Complete technical documentation
```

---

## 6. TEST PLAN

### 6.1 Unit Tests (15 tests total)

#### TestInertiaEstimatorAccuracy (6 tests)
- `test_batch_identification_known_J`: Verify batch ID with synthetic data (J=0.5)
- `test_batch_identification_varying_R`: Test across radius range 50-150mm
- `test_friction_separation`: Validate f_coulomb vs f_viscous separation
- `test_analytical_model_match`: Compare identified Ï with known material
- `test_precision_tolerance`: Verify Â±5% accuracy requirement
- `test_uncertainty_quantification`: Validate uncertainty calculation

#### TestInertiaEstimatorConvergence (4 tests)
- `test_convergence_time`: Verify <10s convergence from IDLEâ†’CONFIRMED
- `test_rls_update_stability`: Check RLS doesn't diverge over 1000 steps
- `test_state_transitions`: Validate state machine (IDLEâ†’IDENTIFYINGâ†’CONFIRMED)
- `test_reidentification_trigger`: Verify re-ID when Î”J > 20%

#### TestInertiaEstimatorRobustness (5 tests)
- `test_noise_rejection`: Â±2% noise â†’ accuracy degrades <10%
- `test_low_velocity_deferral`: No identification when v < 5 m/min
- `test_timeout_handling`: Revert to nominal model if convergence fails
- `test_parameter_drift_detection`: Detect gradual J change over time
- `test_edge_case_zero_acceleration`: Handle Î± â‰ˆ 0 gracefully

### 6.2 Validation Tests (4 scenarios)

#### [TEST 1] Precision Requirement
```
Scenario: Identify known inertia from digital twin
Expected: |J_identified - J_true| / J_true < 5%
```

#### [TEST 2] Convergence Time
```
Scenario: Cold start from IDLE state
Expected: State = CONFIRMED within 10 seconds
```

#### [TEST 3] Online Update Stability
```
Scenario: Run RLS for 100 seconds continuous
Expected: Î¸ variance < 2% (stable estimates)
```

#### [TEST 4] Material Change Detection
```
Scenario: Switch material (Ï: 1390 â†’ 2000 kg/mÂ³)
Expected: Detect change, re-identify within 15s
```

---

## 7. VALIDATION CRITERIA

### Success Metrics

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| **Precision** | <5% error | Compare J_identified vs J_true (digital twin) |
| **Convergence** | <10s | Time from IDLE to CONFIRMED state |
| **Latency** | <200ms | Single update() call execution time |
| **Robustness** | 15/15 tests pass | pytest test suite |

### Industry Benchmarks

| Vendor | Method | Precision | Convergence Time |
|--------|--------|-----------|------------------|
| **ABB DTC** | Auto-tuning | Â±10% | 20-30s |
| **Siemens Sync** | Model-based | Â±8% | 15s |
| **Lenze Manual** | Manual entry | Â±20% | N/A (offline) |
| **ProWinder T2.1.2** | Physics + RLS | **Â±5%** | **<10s** |

---

## 8. DEPENDENCIES

### 8.1 Internal Dependencies
- **T2.1.1** (RadiusCalculator): Provides R(t) for J_web calculation âœ…
- Digital Twin (Phase 1): Simulation environment for testing âœ…

### 8.2 External Dependencies
- `numpy`: Matrix operations, least-squares
- `scipy.linalg`: Covariance matrix inversion
- `dataclasses`: Output structure

### 8.3 Data Dependencies
- Motor torque command: `Ï„_motor` (from motor controller)
- Angular velocity: `Ï‰` (from encoder)
- Angular acceleration: `Î± = dÏ‰/dt` (calculated)
- Web tension: `T_web` (from load cell OR T2.1.3 observer)
- Winding radius: `R` (from T2.1.1 RadiusCalculator)

---

## 9. RISKS & MITIGATIONS

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| **RLS divergence** | Medium | High | Add bounds checking, covariance reset logic |
| **Insufficient excitation** | High | Medium | Detect low Î± variance, defer identification |
| **Noise sensitivity** | Medium | Medium | Implement outlier rejection (3Ïƒ rule) |
| **Convergence timeout** | Low | Medium | Fallback to nominal model (conservative J) |
| **T_web uncertainty** | High | High | Use T2.1.3 observer OR analytical model if no sensor |

---

## 10. DELIVERABLES

### Week 1-2 (Research & Spec)
- âœ… This specification document
- [ ] `T2.1.2_Test_Plan.md` (detailed test cases)
- [ ] `T2.1.2_Literature_Notes.md` (reading synthesis)

### Week 3-4 (Implementation & Validation)
- [ ] `src/prowinder/control/inertia_estimator.py` (450 lines)
- [ ] `tests/test_inertia_estimator.py` (300 lines)
- [ ] `scripts/validation/validate_T2.1.2.py` (150 lines)
- [ ] `docs/algorithms/InertiaEstimator.md` (400 lines)
- [ ] `docs/validation/T2.1.2_VALIDATION_REPORT.md`

---

## 11. REFERENCES

### Primary Sources
1. ISATrans2007-WebWinding.pdf: J_web formula, system parameters
2. IFAC 2000 "Modeling-Identification...": RLS methodology
3. IFAC 2000 "Practical-Combined-Parameter...": EIV approach

### Implementation Guidance
4. `docs/bibliography/PHASE_2_IMPLEMENTATION_SYNTHESIS.md`: Equations & code templates
5. `docs/bibliography/IFAC_2000_CONTROL_PATTERNS.md`: Step response algorithm

### Industry Standards
6. Lenze Application Handbook: Auto-tuning procedures
7. Siemens SINAMICS Manual: Inertia identification
8. ABB DTC Guide: Online parameter estimation

---

**Document Status:** âœ… COMPLETE - Ready for Implementation  
**Next Step:** Begin coding `inertia_estimator.py`  
**Estimated Start:** February 18, 2026  
**Target Completion:** March 16, 2026 (4 weeks)
